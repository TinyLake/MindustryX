From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Thu, 27 Jun 2024 22:41:02 +0800
Subject: [PATCH] =?UTF-8?q?FC(LogicExt)=20terrainSchematic=20(=E5=9C=B0?=
 =?UTF-8?q?=E5=BD=A2=E8=93=9D=E5=9B=BE)?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 core/src/mindustry/game/Schematics.java       | 38 ++++++++++++++++---
 .../world/blocks/environment/Floor.java       | 37 ++++++++++++------
 2 files changed, 57 insertions(+), 18 deletions(-)

diff --git a/core/src/mindustry/game/Schematics.java b/core/src/mindustry/game/Schematics.java
index 2da5a90379f9b9896cdef7ac1540c34fe472d649..0098805f982c8b85ae9f0aa90ec74ffed04366bb 100644
--- a/core/src/mindustry/game/Schematics.java
+++ b/core/src/mindustry/game/Schematics.java
@@ -34,6 +34,7 @@ import mindustry.world.blocks.sandbox.*;
 import mindustry.world.blocks.storage.*;
 import mindustry.world.blocks.storage.CoreBlock.*;
 import mindustry.world.meta.*;
+import mindustryX.features.*;
 
 import java.io.*;
 import java.util.zip.*;
@@ -278,7 +279,7 @@ public class Schematics implements Loadable{
     /** Creates an array of build plans from a schematic's data, centered on the provided x+y coordinates. */
     public Seq<BuildPlan> toPlans(Schematic schem, int x, int y){
         return schem.tiles.map(t -> new BuildPlan(t.x + x - schem.width/2, t.y + y - schem.height/2, t.rotation, t.block, t.config).original(t.x, t.y, schem.width, schem.height))
-            .removeAll(s -> (!s.block.isVisible() && !(s.block instanceof CoreBlock)) || !s.block.unlockedNow()).sort(Structs.comparingInt(s -> -s.block.schematicPriority));
+            .removeAll(s -> !LogicExt.terrainSchematic && ((!s.block.isVisible() && !(s.block instanceof CoreBlock)) || !s.block.unlockedNow())).sort(Structs.comparingInt(s -> -s.block.schematicPriority));
     }
 
     /** @return all the valid loadouts for a specific core type. */
@@ -369,10 +370,10 @@ public class Schematics implements Loadable{
     public Schematic create(int x, int y, int x2, int y2){
         Team team = headless ? null : Vars.player.team();
         NormalizeResult result = Placement.normalizeArea(x, y, x2, y2, 0, false, maxSchematicSize);
-        x = result.x;
-        y = result.y;
-        x2 = result.x2;
-        y2 = result.y2;
+        x = Mathf.clamp(result.x, 0, world.width() - 1);
+        y = Mathf.clamp(result.y, 0, world.height() - 1);
+        x2 = Mathf.clamp(result.x2, 0, world.width() - 1);
+        y2 = Mathf.clamp(result.y2, 0, world.height() - 1);
 
         int ox = x, oy = y, ox2 = x2, oy2 = y2;
 
@@ -399,7 +400,7 @@ public class Schematics implements Loadable{
             }
         }
 
-        if(found){
+        if(found || LogicExt.terrainSchematic){
             x = minx;
             y = miny;
             x2 = maxx;
@@ -408,6 +409,22 @@ public class Schematics implements Loadable{
             return new Schematic(new Seq<>(), new StringMap(), 1, 1);
         }
 
+        if(LogicExt.terrainSchematic){
+            x = Math.min(x, ox + 1);
+            x2 = Math.max(x2, ox2 - 1);
+            y = Math.min(y, oy + 1);
+            y2 = Math.max(y2, oy2 - 1);
+            for(int cx = ox; cx <= ox2; cx++){
+                for(int cy = oy; cy <= oy2; cy++){
+                    Tile tile = world.tile(cx, cy);
+                    tiles.add(new Stile(tile.floor(), tile.x - x, tile.y - y, null, (byte)0));
+                    if(!tile.overlay().isAir())
+                        tiles.add(new Stile(tile.overlay(), tile.x - x, tile.y - y, null, (byte)0));
+                    if(!tile.block().isAir() && tile.build == null)
+                        tiles.add(new Stile(tile.block(), tile.x - x, tile.y - y, null, (byte)0));
+                }
+            }
+        }
         int width = x2 - x + 1, height = y2 - y + 1;
         int offsetX = -x, offsetY = -y;
         IntSet counted = new IntSet();
@@ -426,6 +443,15 @@ public class Schematics implements Loadable{
                 }
             }
         }
+        if(LogicExt.terrainSchematic){
+            for(int cx = ox; cx <= ox2; cx++){
+                for(int cy = oy; cy <= oy2; cy++){
+                    Tile tile = world.tile(cx, cy);
+                    if(!tile.block().isAir() && (tile.build == null || counted.add(tile.build.pos())))
+                        tiles.add(new Stile(tile.block(), tile.x - x, tile.y - y, null, (byte)0));
+                }
+            }
+        }
 
         return new Schematic(tiles, new StringMap(), width, height);
     }
diff --git a/core/src/mindustry/world/blocks/environment/Floor.java b/core/src/mindustry/world/blocks/environment/Floor.java
index dc056da237eda03e3c04328cf648a1c29df55154..facd6d75710f4d3628cb9f058674feadc37ac732 100644
--- a/core/src/mindustry/world/blocks/environment/Floor.java
+++ b/core/src/mindustry/world/blocks/environment/Floor.java
@@ -77,19 +77,21 @@ public class Floor extends Block{
     public int blendId = -1;
 
     protected TextureRegion[][] edges;
-    protected Seq<Block> blenders = new Seq<>();
+    protected Seq<Floor> blenders = new Seq<>();
     protected Bits blended = new Bits(256);
     protected int[] dirs = new int[8];
     protected TextureRegion edgeRegion;
 
     public Floor(String name){
-        super(name);
-        variants = 3;
+        this(name, 3);
     }
 
     public Floor(String name, int variants){
         super(name);
         this.variants = variants;
+        placeableLiquid = true;
+        placeEffect = Fx.rotateBlock;
+        schematicPriority = 100;
     }
 
     @Override
@@ -174,18 +176,23 @@ public class Floor extends Block{
         }
 
         packer.add(PageType.environment, name + "-edge", result);
+        result.dispose();
     }
 
     @Override
     public void drawBase(Tile tile){
         Mathf.rand.setSeed(tile.pos());
-        Draw.rect(variantRegions[Mathf.randomSeed(tile.pos(), 0, Math.max(0, variantRegions.length - 1))], tile.worldx(), tile.worldy());
+        Draw.rect(variantRegions[variant(tile.x, tile.y)], tile.worldx(), tile.worldy());
 
         Draw.alpha(1f);
         drawEdges(tile);
         drawOverlay(tile);
     }
 
+    public int variant(int x, int y){
+        return Mathf.randomSeed(Point2.pack(x, y), 0, Math.max(0, variantRegions.length - 1));
+    }
+
     public void drawOverlay(Tile tile){
         Floor floor = tile.overlay();
         if(floor != Blocks.air && floor != this){
@@ -270,12 +277,12 @@ public class Floor extends Block{
     protected void drawBlended(Tile tile, boolean checkId){
         blenders.sort(a -> a.id);
 
-        for(Block block : blenders){
+        for(Floor block : blenders){
             for(int i = 0; i < 8; i++){
                 Point2 point = Geometry.d8[i];
                 Tile other = tile.nearby(point);
                 if(other != null && other.floor() == block && (!checkId || dirs[i] == block.id)){
-                    TextureRegion region = edge((Floor)block, 1 - point.x, 1 - point.y);
+                    TextureRegion region = block.edge(tile.x, tile.y, 1 - point.x, 1 - point.y);
                     Draw.rect(region, tile.worldx(), tile.worldy());
                 }
             }
@@ -302,17 +309,23 @@ public class Floor extends Block{
         return blendId;
     }
 
+    /** Returns the edge array that should be used to draw at the specified tile position. */
+    protected TextureRegion[][] edges(int x, int y){
+        return blendGroup.asFloor().edges;
+    }
+
+    protected TextureRegion edge(int x, int y, int rx, int ry){
+        return edges(x, y)[rx][2 - ry];
+    }
+
+    @Deprecated
     protected TextureRegion[][] edges(){
-        return ((Floor)blendGroup).edges;
+        return edges(0, 0);
     }
 
     /** @return whether the edges from {@param other} should be drawn onto this tile **/
     protected boolean doEdge(Tile tile, Tile otherTile, Floor other){
-        return (other.realBlendId(otherTile) > realBlendId(tile) || edges() == null);
-    }
-
-    TextureRegion edge(Floor block, int x, int y){
-        return block.edges()[x][2 - y];
+        return (other.realBlendId(otherTile) > realBlendId(tile) || edges(tile.x, tile.y) == null);
     }
 
     public static class UpdateRenderState{
