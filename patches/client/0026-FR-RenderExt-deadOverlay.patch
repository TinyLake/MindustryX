From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Fri, 2 Aug 2024 23:36:02 +0800
Subject: [PATCH] FR(RenderExt) deadOverlay

---
 core/src/mindustry/graphics/OverlayRenderer.java |  6 +++---
 core/src/mindustry/input/DesktopInput.java       | 15 ++++++++-------
 core/src/mindustry/input/InputHandler.java       |  2 ++
 3 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/core/src/mindustry/graphics/OverlayRenderer.java b/core/src/mindustry/graphics/OverlayRenderer.java
index 78533c7fe78ce26a184f6251a5d0ae5de6298d5d..f1c07752bbe7d710bd11b255a95dade86c4ebeb4 100644
--- a/core/src/mindustry/graphics/OverlayRenderer.java
+++ b/core/src/mindustry/graphics/OverlayRenderer.java
@@ -75,7 +75,7 @@ public class OverlayRenderer{
     public void drawBottom(){
         InputHandler input = control.input;
 
-        if(player.dead()) return;
+        if(player.dead() && !RenderExt.deadOverlay.get()) return;
 
         if(player.isBuilder()){
             player.unit().drawBuildPlans();
@@ -152,10 +152,10 @@ public class OverlayRenderer{
             tile.drawConfigure();
         }
 
-        if(!player.dead()) input.drawTop();
+        if(!player.dead() || RenderExt.deadOverlay.get()) input.drawTop();
         input.drawUnitSelection();
 
-        if(player.dead()) return; //dead players don't draw
+        if(player.dead() && !RenderExt.deadOverlay.get()) return; //dead players don't draw
 
         buildFade = Mathf.lerpDelta(buildFade, input.isPlacing() || input.isUsingSchematic() ? 1f : 0f, 0.06f);
 
diff --git a/core/src/mindustry/input/DesktopInput.java b/core/src/mindustry/input/DesktopInput.java
index c50c591559a1ba5fba57c484d14a86d2d5cd86db..1b398a99d5c870f091da5cbe6f0a7dd44803301d 100644
--- a/core/src/mindustry/input/DesktopInput.java
+++ b/core/src/mindustry/input/DesktopInput.java
@@ -483,6 +483,7 @@ public class DesktopInput extends InputHandler{
             cursorType = SystemCursor.arrow;
             if(!locked){
                 pollInputNoPlayer();
+                if(RenderExt.deadOverlay.get()) pollInputPlayer();
             }
         }else{
             pollInputPlayer();
@@ -567,7 +568,7 @@ public class DesktopInput extends InputHandler{
         int rawCursorX = World.toTile(Core.input.mouseWorld().x), rawCursorY = World.toTile(Core.input.mouseWorld().y);
 
         //automatically pause building if the current build queue is empty
-        if(Core.settings.getBool("buildautopause") && isBuilding && !player.unit().isBuilding()){
+        if(!player.dead() && Core.settings.getBool("buildautopause") && isBuilding && !player.unit().isBuilding()){
             isBuilding = false;
             buildWasAutoPaused = true;
         }
@@ -584,7 +585,7 @@ public class DesktopInput extends InputHandler{
             schematicY += shiftY;
         }
 
-        if(Core.input.keyTap(Binding.deselect) && !ui.minimapfrag.shown() && !isPlacing() && player.unit().plans.isEmpty() && !commandMode){
+        if(!player.dead() && Core.input.keyTap(Binding.deselect) && !ui.minimapfrag.shown() && !isPlacing() && player.unit().plans.isEmpty() && !commandMode){
             player.unit().mineTile = null;
         }
 
@@ -658,7 +659,7 @@ public class DesktopInput extends InputHandler{
             lastLineY = cursorY;
         }
 
-        if(Core.input.keyRelease(Binding.select) && !Core.scene.hasMouse()){
+        if(!player.dead() && Core.input.keyRelease(Binding.select) && !Core.scene.hasMouse()){
             BuildPlan plan = getPlan(cursorX, cursorY);
 
             if(plan != null && !movedPlan){
@@ -678,7 +679,7 @@ public class DesktopInput extends InputHandler{
             if(Core.input.keyDown(Binding.breakBlock)){
                 mode = none;
             }else if(!selectPlans.isEmpty()){
-                flushPlans(selectPlans);
+                if(player.isBuilder()) flushPlans(selectPlans);
                 movedPlan = true;
             }else if(isPlacing()){
                 selectX = cursorX;
@@ -700,7 +701,7 @@ public class DesktopInput extends InputHandler{
                 commandRectY = input.mouseWorldY();
             }else if(!checkConfigTap() && selected != null && !tryRepairDerelict(selected)){
                 //only begin shooting if there's no cursor event
-                if(!tryTapPlayer(Core.input.mouseWorld().x, Core.input.mouseWorld().y) && !tileTapped(selected.build) && !player.unit().activelyBuilding() && !droppingItem
+                if(!player.dead() && !tryTapPlayer(Core.input.mouseWorld().x, Core.input.mouseWorld().y) && !tileTapped(selected.build) && !player.unit().activelyBuilding() && !droppingItem
                     && !(tryStopMine(selected) || (!settings.getBool("doubletapmine") || selected == prevSelected && Time.timeSinceMillis(selectMillis) < 500) && tryBeginMine(selected)) && !Core.scene.hasKeyboard()){
                     player.shooting = shouldShoot;
                 }
@@ -725,7 +726,7 @@ public class DesktopInput extends InputHandler{
             schemY = rawCursorY;
         }
 
-        if(Core.input.keyDown(Binding.select) && mode == none && !isPlacing() && deleting){
+        if(!player.dead() && Core.input.keyDown(Binding.select) && mode == none && !isPlacing() && deleting){
             var plan = getPlan(cursorX, cursorY);
             if(plan != null && plan.breaking){
                 player.unit().plans().remove(plan);
@@ -749,7 +750,7 @@ public class DesktopInput extends InputHandler{
             schemY = -1;
         }
 
-        if(Core.input.keyRelease(Binding.breakBlock) || Core.input.keyRelease(Binding.select)){
+        if(!player.dead() && (Core.input.keyRelease(Binding.breakBlock) || Core.input.keyRelease(Binding.select))){
 
             if(mode == placing && block != null){ //touch up while placing, place everything in selection
                 if(input.keyDown(Binding.boost)){
diff --git a/core/src/mindustry/input/InputHandler.java b/core/src/mindustry/input/InputHandler.java
index 93f18140b4d49661e469b115c7c0751520ce035e..150a05c7e6f300d4347d61e729bdc93e3cbff349 100644
--- a/core/src/mindustry/input/InputHandler.java
+++ b/core/src/mindustry/input/InputHandler.java
@@ -2128,6 +2128,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     }
 
     public boolean canShoot(){
+        if(player.dead()) return false;
         return block == null && !onConfigurable() && !isDroppingItem() && !player.unit().activelyBuilding() &&
         !(player.unit() instanceof Mechc && player.unit().isFlying()) && !player.unit().mining() && !commandMode;
     }
@@ -2177,6 +2178,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     }
 
     public void rebuildArea(int x1, int y1, int x2, int y2){
+        if(!player.isBuilder()) return;
         NormalizeResult result = Placement.normalizeArea(x1, y1, x2, y2, rotation, false, 999999999);
         Tmp.r1.set(result.x * tilesize, result.y * tilesize, (result.x2 - result.x) * tilesize, (result.y2 - result.y) * tilesize);
 
