From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Fri, 2 Aug 2024 23:36:02 +0800
Subject: [PATCH] FR(RenderExt) deadOverlay

---
 core/src/mindustry/graphics/OverlayRenderer.java |  6 +++---
 core/src/mindustry/input/DesktopInput.java       | 15 ++++++++-------
 core/src/mindustry/input/InputHandler.java       |  2 ++
 3 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/core/src/mindustry/graphics/OverlayRenderer.java b/core/src/mindustry/graphics/OverlayRenderer.java
index 0470ec54fed4b2aea4b9bfd0c6639ac034fc726d..4354963da51ef7ccefafec061635fced40457260 100644
--- a/core/src/mindustry/graphics/OverlayRenderer.java
+++ b/core/src/mindustry/graphics/OverlayRenderer.java
@@ -71,7 +71,7 @@ public class OverlayRenderer{
     public void drawBottom(){
         InputHandler input = control.input;
 
-        if(player.dead()) return;
+        if(player.dead() && !RenderExt.deadOverlay.get()) return;
 
         if(player.isBuilder()){
             player.unit().drawBuildPlans();
@@ -148,10 +148,10 @@ public class OverlayRenderer{
             tile.drawConfigure();
         }
 
-        if(!player.dead()) input.drawTop();
+        if(!player.dead() || RenderExt.deadOverlay.get()) input.drawTop();
         input.drawUnitSelection();
 
-        if(player.dead()) return; //dead players don't draw
+        if(player.dead() && !RenderExt.deadOverlay.get()) return; //dead players don't draw
 
         buildFade = Mathf.lerpDelta(buildFade, input.isPlacing() || input.isUsingSchematic() ? 1f : 0f, 0.06f);
 
diff --git a/core/src/mindustry/input/DesktopInput.java b/core/src/mindustry/input/DesktopInput.java
index 311b6a123e3f4f41674dcd892a868fe9c76b7c58..d267d7b07438552009e5260c779051390d815972 100644
--- a/core/src/mindustry/input/DesktopInput.java
+++ b/core/src/mindustry/input/DesktopInput.java
@@ -477,6 +477,7 @@ public class DesktopInput extends InputHandler{
             cursorType = SystemCursor.arrow;
             if(!locked){
                 pollInputNoPlayer();
+                if(RenderExt.deadOverlay.get()) pollInputPlayer();
             }
         }else{
             pollInputPlayer();
@@ -553,7 +554,7 @@ public class DesktopInput extends InputHandler{
         int rawCursorX = World.toTile(Core.input.mouseWorld().x), rawCursorY = World.toTile(Core.input.mouseWorld().y);
 
         //automatically pause building if the current build queue is empty
-        if(Core.settings.getBool("buildautopause") && isBuilding && !player.unit().isBuilding()){
+        if(!player.dead() && Core.settings.getBool("buildautopause") && isBuilding && !player.unit().isBuilding()){
             isBuilding = false;
             buildWasAutoPaused = true;
         }
@@ -570,7 +571,7 @@ public class DesktopInput extends InputHandler{
             schematicY += shiftY;
         }
 
-        if(Core.input.keyTap(Binding.deselect) && !ui.minimapfrag.shown() && !isPlacing() && player.unit().plans.isEmpty() && !commandMode){
+        if(!player.dead() && Core.input.keyTap(Binding.deselect) && !ui.minimapfrag.shown() && !isPlacing() && player.unit().plans.isEmpty() && !commandMode){
             player.unit().mineTile = null;
         }
 
@@ -644,7 +645,7 @@ public class DesktopInput extends InputHandler{
             lastLineY = cursorY;
         }
 
-        if(Core.input.keyRelease(Binding.select) && !Core.scene.hasMouse()){
+        if(!player.dead() && Core.input.keyRelease(Binding.select) && !Core.scene.hasMouse()){
             BuildPlan plan = getPlan(cursorX, cursorY);
 
             if(plan != null && !movedPlan){
@@ -664,7 +665,7 @@ public class DesktopInput extends InputHandler{
             if(Core.input.keyDown(Binding.breakBlock)){
                 mode = none;
             }else if(!selectPlans.isEmpty()){
-                flushPlans(selectPlans);
+                if(player.isBuilder()) flushPlans(selectPlans);
                 movedPlan = true;
             }else if(isPlacing()){
                 selectX = cursorX;
@@ -686,7 +687,7 @@ public class DesktopInput extends InputHandler{
                 commandRectY = input.mouseWorldY();
             }else if(!checkConfigTap() && selected != null && !tryRepairDerelict(selected)){
                 //only begin shooting if there's no cursor event
-                if(!tryTapPlayer(Core.input.mouseWorld().x, Core.input.mouseWorld().y) && !tileTapped(selected.build) && !player.unit().activelyBuilding() && !droppingItem
+                if(!player.dead() && !tryTapPlayer(Core.input.mouseWorld().x, Core.input.mouseWorld().y) && !tileTapped(selected.build) && !player.unit().activelyBuilding() && !droppingItem
                     && !(tryStopMine(selected) || (!settings.getBool("doubletapmine") || selected == prevSelected && Time.timeSinceMillis(selectMillis) < 500) && tryBeginMine(selected)) && !Core.scene.hasKeyboard()){
                     player.shooting = shouldShoot;
                 }
@@ -711,7 +712,7 @@ public class DesktopInput extends InputHandler{
             schemY = rawCursorY;
         }
 
-        if(Core.input.keyDown(Binding.select) && mode == none && !isPlacing() && deleting){
+        if(!player.dead() && Core.input.keyDown(Binding.select) && mode == none && !isPlacing() && deleting){
             var plan = getPlan(cursorX, cursorY);
             if(plan != null && plan.breaking){
                 player.unit().plans().remove(plan);
@@ -735,7 +736,7 @@ public class DesktopInput extends InputHandler{
             schemY = -1;
         }
 
-        if(Core.input.keyRelease(Binding.breakBlock) || Core.input.keyRelease(Binding.select)){
+        if(!player.dead() && (Core.input.keyRelease(Binding.breakBlock) || Core.input.keyRelease(Binding.select))){
 
             if(mode == placing && block != null){ //touch up while placing, place everything in selection
                 if(input.keyDown(Binding.boost)){
diff --git a/core/src/mindustry/input/InputHandler.java b/core/src/mindustry/input/InputHandler.java
index 6a52833182f96b0c4d0f09b961cd3d3302164890..9dfb1a2db26cecb854016ef3cc186b9b464f9a25 100644
--- a/core/src/mindustry/input/InputHandler.java
+++ b/core/src/mindustry/input/InputHandler.java
@@ -2055,6 +2055,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     }
 
     public boolean canShoot(){
+        if(player.dead()) return false;
         return block == null && !onConfigurable() && !isDroppingItem() && !player.unit().activelyBuilding() &&
         !(player.unit() instanceof Mechc && player.unit().isFlying()) && !player.unit().mining() && !commandMode;
     }
@@ -2096,6 +2097,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
     }
 
     public void rebuildArea(int x1, int y1, int x2, int y2){
+        if(!player.isBuilder()) return;
         NormalizeResult result = Placement.normalizeArea(x1, y1, x2, y2, rotation, false, 999999999);
         Tmp.r1.set(result.x * tilesize, result.y * tilesize, (result.x2 - result.x) * tilesize, (result.y2 - result.y) * tilesize);
 
